{"version":3,"sources":["vg.js","Board.js","grids/Cell.js","grids/HexGrid.js","grids/SqrGrid.js","grids/Tile.js"],"names":["vg","VERSION","PI","Math","TAU","DEG_TO_RAD","RAD_TO_DEG","SQRT3","sqrt","TILE","ENT","STR","HEX","SQR","ABS","Board","grid","finderConfig","Error","this","tiles","tileGroup","group","THREE","Object3D","overlay","finder","AStarFinder","Loader","init","setGrid","prototype","setEntityOnTile","entity","tile","pos","cellToPixel","cell","position","copy","y","heightOffset","setEntityOnTileWithOffset","xOffset","zOffset","console","log","x","z","addTile","i","indexOf","push","snapTileToGrid","add","mesh","removeTile","remove","splice","dispose","removeAllTiles","children","length","getTileAtCell","h","cellToHash","cells","snapToGrid","pixelToCell","getRandomTile","Tools","randomInt","findPath","startTile","endTile","heuristic","newGrid","forEach","t","generateOverlay","size","mat","LineBasicMaterial","color","opacity","generateTilemap","config","reset","generateTiles","constructor","Cell","q","r","s","userData","walkable","_calcCost","_priority","_visited","_parent","uniqueID","LinkedList","generateID","set","equals","HexGrid","type","cellSize","numCells","extrudeSettings","autogenerated","verts","_createVertex","cellShape","Shape","moveTo","lineTo","autoClose","cellGeo","Geometry","vertices","verticesNeedUpdate","cellShapeGeo","ShapeGeometry","_cellWidth","_cellLength","_hashDelimeter","_directions","_diagonals","_list","_vec3","Vector3","_cel","_conversionVec","_geoCache","_matCache","TWO_THIRDS","_cubeRound","getCellAt","getNeighbors","diagonal","filter","n","l","getRandomCell","c","distance","cellA","cellB","d","max","abs","clearPath","traverse","cb","generateTile","scale","material","height","geo","amount","ExtrudeGeometry","Tile","geometry","settings","tileScale","bevelEnabled","bevelSegments","steps","bevelSize","bevelThickness","merge","generateTilePoly","MeshBasicMaterial","Mesh","rotateOnAxis","generate","overlayObj","overlayMat","createPointsGeometry","line","Line","rotation","load","url","scope","self","getJSON","callback","json","fromJSON","call","cache","toJSON","k","angle","cos","sin","rx","round","ry","rz","xDiff","yDiff","zDiff","SqrGrid","_fullCellSize","half","ceil","MeshPhongMaterial","randomizeRGB","objectType","selected","highlight","structure","emissive","_emissive","getHex","customizeTile","select","setHex","deselect","toggle","updateTerrain","updateCity","setTerrain","terrain","setCity","name","city","setCityPosition","colorString","Color","spriteConfig","container","board","sprite","Sprite","activate","parent"],"mappings":"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","file":"von-grid.min.js","sourcesContent":["var vg = { // eslint-disable-line\n\tVERSION: '0.1.1',\n\n\tPI: Math.PI,\n\tTAU: Math.PI * 2,\n\tDEG_TO_RAD: 0.0174532925,\n\tRAD_TO_DEG: 57.2957795,\n\tSQRT3: Math.sqrt(3), // used often in hex conversions\n\n\t// useful enums for type checking. change to whatever fits your game. these are just examples\n\tTILE: 'tile', // visual representation of a grid cell\n\tENT: 'entity', // dynamic things\n\tSTR: 'structure', // static things\n\n\tHEX: 'hex',\n\tSQR: 'square',\n\tABS: 'abstract'\n};\n","/*\n\tInterface to the grid. Holds data about the visual representation of the cells (tiles).\n\n\t@author Corey Birnbaum https://github.com/vonWolfehaus/\n */\nvg.Board = function(grid, finderConfig) {\n\tif (!grid) throw new Error('You must pass in a grid system for the board to use.');\n\n\tthis.tiles = [];\n\tthis.tileGroup = null; // only for tiles\n\n\tthis.group = new THREE.Object3D(); // can hold all entities, also holds tileGroup, never trashed\n\n\tthis.grid = null;\n\tthis.overlay = null;\n\tthis.finder = new vg.AStarFinder(finderConfig);\n\t// need to keep a resource cache around, so this Loader does that, use it instead of THREE.ImageUtils\n\tvg.Loader.init();\n\n\tthis.setGrid(grid);\n};\n\nvg.Board.prototype = {\n\tsetEntityOnTile: function(entity, tile) {\n\t\t// snap an entity's position to a tile; merely copies position\n\t\tvar pos = this.grid.cellToPixel(tile.cell);\n\t\tentity.position.copy(pos);\n\t\t// adjust for any offset after the entity was set directly onto the tile\n\t\tentity.position.y += entity.heightOffset || 0;\n\t\t// remove entity from old tile\n\t\tif (entity.tile) {\n\t\t\tentity.tile.entity = null;\n\t\t}\n\t\t// set new situation\n\t\tentity.tile = tile;\n\t\ttile.entity = entity;\n\t},\n\n  setEntityOnTileWithOffset: function(entity, tile, xOffset, zOffset) {\n\n\t  console.log('setEntityWithOffset');\n    // snap an entity's position to a tile; merely copies position\n    var pos = this.grid.cellToPixel(tile.cell);\n    entity.position.copy(pos);\n    // adjust for any offset after the entity was set directly onto the tile\n    entity.position.y += entity.heightOffset || 0;\n    entity.position.x += xOffset || 0;\n    entity.position.z += zOffset || 0;\n\n    console.log('entity.position.x: ', entity.position.x);\n    console.log('entity.position.y: ', entity.position.y);\n    console.log('entity.position.z: ', entity.position.z);\n\n    // remove entity from old tile\n    if (entity.tile) {\n      entity.tile.entity = null;\n    }\n    // set new situation\n    entity.tile = tile;\n    tile.entity = entity;\n  },\n\n\taddTile: function(tile) {\n\t\tvar i = this.tiles.indexOf(tile);\n\t\tif (i === -1) this.tiles.push(tile);\n\t\telse return;\n\n\t\tthis.snapTileToGrid(tile);\n\t\ttile.position.y = 0;\n\n\t\tthis.tileGroup.add(tile.mesh);\n\t\tthis.grid.add(tile.cell);\n\n\t\ttile.cell.tile = tile;\n\t},\n\n\tremoveTile: function(tile) {\n\t\tif (!tile) return; // was already removed somewhere\n\t\tvar i = this.tiles.indexOf(tile);\n\t\tthis.grid.remove(tile.cell);\n\n\t\tif (i !== -1) this.tiles.splice(i, 1);\n\t\t// this.tileGroup.remove(tile.mesh);\n\n\t\ttile.dispose();\n\t},\n\n\tremoveAllTiles: function() {\n\t\tif (!this.tileGroup) return;\n\t\tvar tiles = this.tileGroup.children;\n\t\tfor (var i = 0; i < tiles.length; i++) {\n\t\t\tthis.tileGroup.remove(tiles[i]);\n\t\t}\n\t},\n\n\tgetTileAtCell: function(cell) {\n\t\tvar h = this.grid.cellToHash(cell);\n\t\treturn cell.tile || (typeof this.grid.cells[h] !== 'undefined' ? this.grid.cells[h].tile : null);\n\t},\n\n\tsnapToGrid: function(pos) {\n\t\tvar cell = this.grid.pixelToCell(pos);\n\t\tpos.copy(this.grid.cellToPixel(cell));\n\t},\n\n\tsnapTileToGrid: function(tile) {\n\t\tif (tile.cell) {\n\t\t\ttile.position.copy(this.grid.cellToPixel(tile.cell));\n\t\t}\n\t\telse {\n\t\t\tvar cell = this.grid.pixelToCell(tile.position);\n\t\t\ttile.position.copy(this.grid.cellToPixel(cell));\n\t\t}\n\t\treturn tile;\n\t},\n\n\tgetRandomTile: function() {\n\t\tvar i = vg.Tools.randomInt(0, this.tiles.length-1);\n\t\treturn this.tiles[i];\n\t},\n\n\tfindPath: function(startTile, endTile, heuristic) {\n\t\treturn this.finder.findPath(startTile.cell, endTile.cell, heuristic, this.grid);\n\t},\n\n\tsetGrid: function(newGrid) {\n\t\tthis.group.remove(this.tileGroup);\n\t\tif (this.grid && newGrid !== this.grid) {\n\t\t\tthis.removeAllTiles();\n\t\t\tthis.tiles.forEach(function(t) {\n\t\t\t\tthis.grid.remove(t.cell);\n\t\t\t\tt.dispose();\n\t\t\t});\n\t\t\tthis.grid.dispose();\n\t\t}\n\t\tthis.grid = newGrid;\n\t\tthis.tiles = [];\n\t\tthis.tileGroup = new THREE.Object3D();\n\t\tthis.group.add(this.tileGroup);\n\t},\n\n\tgenerateOverlay: function(size) {\n\t\tvar mat = new THREE.LineBasicMaterial({\n\t\t\tcolor: 0x000000,\n\t\t\topacity: 0.3\n\t\t});\n\n\t\tif (this.overlay) {\n\t\t\tthis.group.remove(this.overlay);\n\t\t}\n\n\t\tthis.overlay = new THREE.Object3D();\n\n\t\tthis.grid.generateOverlay(size, this.overlay, mat);\n\n\t\tthis.group.add(this.overlay);\n\t},\n\n\tgenerateTilemap: function(config) {\n\t\tthis.reset();\n\n\t\tvar tiles = this.grid.generateTiles(config);\n\t\tthis.tiles = tiles;\n\n\t\tthis.tileGroup = new THREE.Object3D();\n\t\tfor (var i = 0; i < tiles.length; i++) {\n\t\t\tthis.tileGroup.add(tiles[i].mesh);\n\t\t}\n\n\t\tthis.group.add(this.tileGroup);\n\t},\n\n\treset: function() {\n\t\t// removes all tiles from the scene, but leaves the grid intact\n\t\tthis.removeAllTiles();\n\t\tif (this.tileGroup) this.group.remove(this.tileGroup);\n\t}\n};\n\nvg.Board.prototype.constructor = vg.Board;\n","/*\n\tSimple structure for holding grid coordinates and extra data about them.\n\n\t@author Corey Birnbaum https://github.com/vonWolfehaus/\n*/\nvg.Cell = function(q, r, s, h) {\n\tthis.q = q || 0; // x grid coordinate (using different letters so that it won't be confused with pixel/world coordinates)\n\tthis.r = r || 0; // y grid coordinate\n\tthis.s = s || 0; // z grid coordinate\n\tthis.h = h || 1; // 3D height of the cell, used by visual representation and pathfinder, cannot be less than 1\n\tthis.tile = null; // optional link to the visual representation's class instance\n\tthis.userData = {}; // populate with any extra data needed in your game\n\tthis.walkable = true; // if true, pathfinder will use as a through node\n\t// rest of these are used by the pathfinder and overwritten at runtime, so don't touch\n\tthis._calcCost = 0;\n\tthis._priority = 0;\n\tthis._visited = false;\n\tthis._parent = null;\n\tthis.uniqueID = vg.LinkedList.generateID();\n};\n\nvg.Cell.prototype = {\n\tset: function(q, r, s) {\n\t\tthis.q = q;\n\t\tthis.r = r;\n\t\tthis.s = s;\n\t\treturn this;\n\t},\n\n\tcopy: function(cell) {\n\t\tthis.q = cell.q;\n\t\tthis.r = cell.r;\n\t\tthis.s = cell.s;\n\t\tthis.h = cell.h;\n\t\tthis.tile = cell.tile || null;\n\t\tthis.userData = cell.userData || {};\n\t\tthis.walkable = cell.walkable;\n\t\treturn this;\n\t},\n\n\tadd: function(cell) {\n\t\tthis.q += cell.q;\n\t\tthis.r += cell.r;\n\t\tthis.s += cell.s;\n\t\treturn this;\n\t},\n\n\tequals: function(cell) {\n\t\treturn this.q === cell.q && this.r === cell.r && this.s === cell.s;\n\t}\n};\n\nvg.Cell.prototype.constructor = vg.Cell;\n","/*\n\tGraph of hexagons. Handles grid cell management (placement math for eg pathfinding, range, etc) and grid conversion math.\n\t[Cube/axial coordinate system](http://www.redblobgames.com/grids/hexagons/), \"flat top\" version only. Since this is 3D, just rotate your camera for pointy top maps.\n\tInterface:\n\ttype\n\tsize - number of cells (in radius); only used if the map is generated\n\tcellSize\n\tcells - a hash so we can have sparse maps\n\tnumCells\n\textrudeSettings\n\tautogenerated\n\tcellShape\n\tcellGeo\n\tcellShapeGeo\n\n\t@author Corey Birnbaum https://github.com/vonWolfehaus/\n */\n// 'utils/Loader', 'graphs/Hex', 'utils/Tools'\nvg.HexGrid = function(config) {\n\tconfig = config || {};\n\t/*  ______________________________________________\n\t\tGRID INTERFACE:\n\t*/\n\tthis.type = vg.HEX;\n\tthis.size = 5; // only used for generated maps\n\tthis.cellSize = typeof config.cellSize === 'undefined' ? 10 : config.cellSize;\n\tthis.cells = {};\n\tthis.numCells = 0;\n\n\tthis.extrudeSettings = null;\n\tthis.autogenerated = false;\n\n\t// create base shape used for building geometry\n\tvar i, verts = [];\n\t// create the skeleton of the hex\n\tfor (i = 0; i < 6; i++) {\n\t\tverts.push(this._createVertex(i));\n\t}\n\t// copy the verts into a shape for the geometry to use\n\tthis.cellShape = new THREE.Shape();\n\tthis.cellShape.moveTo(verts[0].x, verts[0].y);\n\tfor (i = 1; i < 6; i++) {\n\t\tthis.cellShape.lineTo(verts[i].x, verts[i].y);\n\t}\n\tthis.cellShape.lineTo(verts[0].x, verts[0].y);\n\tthis.cellShape.autoClose = true;\n\n\tthis.cellGeo = new THREE.Geometry();\n\tthis.cellGeo.vertices = verts;\n\tthis.cellGeo.verticesNeedUpdate = true;\n\n\tthis.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape);\n\n\t/*  ______________________________________________\n\t\tPRIVATE\n\t*/\n\n\tthis._cellWidth = this.cellSize * 2;\n\tthis._cellLength = (vg.SQRT3 * 0.5) * this._cellWidth;\n\tthis._hashDelimeter = '.';\n\t// pre-computed permutations\n\tthis._directions = [new vg.Cell(+1, -1, 0), new vg.Cell(+1, 0, -1), new vg.Cell(0, +1, -1),\n\t\t\t\t\t\tnew vg.Cell(-1, +1, 0), new vg.Cell(-1, 0, +1), new vg.Cell(0, -1, +1)];\n\tthis._diagonals = [new vg.Cell(+2, -1, -1), new vg.Cell(+1, +1, -2), new vg.Cell(-1, +2, -1),\n\t\t\t\t\t   new vg.Cell(-2, +1, +1), new vg.Cell(-1, -1, +2), new vg.Cell(+1, -2, +1)];\n\t// cached objects\n\tthis._list = [];\n\tthis._vec3 = new THREE.Vector3();\n\tthis._cel = new vg.Cell();\n\tthis._conversionVec = new THREE.Vector3();\n\tthis._geoCache = [];\n\tthis._matCache = [];\n};\n\nvg.HexGrid.TWO_THIRDS = 2 / 3;\n\nvg.HexGrid.prototype = {\n\t/*  ________________________________________________________________________\n\t\tHigh-level functions that the Board interfaces with (all grids implement)\n\t */\n\n\t// grid cell (Hex in cube coordinate space) to position in pixels/world\n\tcellToPixel: function(cell) {\n\t\tthis._vec3.x = cell.q * this._cellWidth * 0.75;\n\t\tthis._vec3.y = cell.h;\n\t\tthis._vec3.z = -((cell.s - cell.r) * this._cellLength * 0.5);\n\t\treturn this._vec3;\n\t},\n\n\tpixelToCell: function(pos) {\n\t\t// convert a position in world space (\"pixels\") to cell coordinates\n\t\tvar q = pos.x * (vg.HexGrid.TWO_THIRDS / this.cellSize);\n\t\tvar r = ((-pos.x / 3) + (vg.SQRT3/3) * pos.z) / this.cellSize;\n\t\tthis._cel.set(q, r, -q-r);\n\t\treturn this._cubeRound(this._cel);\n\t},\n\n\tgetCellAt: function(pos) {\n\t\t// get the Cell (if any) at the passed world position\n\t\tvar q = pos.x * (vg.HexGrid.TWO_THIRDS / this.cellSize);\n\t\tvar r = ((-pos.x / 3) + (vg.SQRT3/3) * pos.z) / this.cellSize;\n\t\tthis._cel.set(q, r, -q-r);\n\t\tthis._cubeRound(this._cel);\n\t\treturn this.cells[this.cellToHash(this._cel)];\n\t},\n\n\tgetNeighbors: function(cell, diagonal, filter) {\n\t\t// always returns an array\n\t\tvar i, n, l = this._directions.length;\n\t\tthis._list.length = 0;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tthis._cel.copy(cell);\n\t\t\tthis._cel.add(this._directions[i]);\n\t\t\tn = this.cells[this.cellToHash(this._cel)];\n\t\t\tif (!n || (filter && !filter(cell, n))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._list.push(n);\n\t\t}\n\t\tif (diagonal) {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tthis._cel.copy(cell);\n\t\t\t\tthis._cel.add(this._diagonals[i]);\n\t\t\t\tn = this.cells[this.cellToHash(this._cel)];\n\t\t\t\tif (!n || (filter && !filter(cell, n))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._list.push(n);\n\t\t\t}\n\t\t}\n\t\treturn this._list;\n\t},\n\n\tgetRandomCell: function() {\n\t\tvar c, i = 0, x = vg.Tools.randomInt(0, this.numCells);\n\t\tfor (c in this.cells) {\n\t\t\tif (i === x) {\n\t\t\t\treturn this.cells[c];\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn this.cells[c];\n\t},\n\n\tcellToHash: function(cell) {\n\t\treturn cell.q+this._hashDelimeter+cell.r+this._hashDelimeter+cell.s;\n\t},\n\n\tdistance: function(cellA, cellB) {\n\t\tvar d = Math.max(Math.abs(cellA.q - cellB.q), Math.abs(cellA.r - cellB.r), Math.abs(cellA.s - cellB.s));\n\t\td += cellB.h - cellA.h; // include vertical height\n\t\treturn d;\n\t},\n\n\tclearPath: function() {\n\t\tvar i, c;\n\t\tfor (i in this.cells) {\n\t\t\tc = this.cells[i];\n\t\t\tc._calcCost = 0;\n\t\t\tc._priority = 0;\n\t\t\tc._parent = null;\n\t\t\tc._visited = false;\n\t\t}\n\t},\n\n\ttraverse: function(cb) {\n\t\tvar i;\n\t\tfor (i in this.cells) {\n\t\t\tcb(this.cells[i]);\n\t\t}\n\t},\n\n\tgenerateTile: function(cell, scale, material) {\n\t\tvar height = Math.abs(cell.h);\n\t\tif (height < 1) height = 1;\n\n\t\tvar geo = this._geoCache[height];\n\t\tif (!geo) {\n\t\t\tthis.extrudeSettings.amount = height;\n\t\t\tgeo = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings);\n\t\t\tthis._geoCache[height] = geo;\n\t\t}\n\n\t\t/*mat = this._matCache[c.matConfig.mat_cache_id];\n\t\tif (!mat) { // MaterialLoader? we currently only support basic stuff though. maybe later\n\t\t\tmat.map = Loader.loadTexture(c.matConfig.imgURL);\n\t\t\tdelete c.matConfig.imgURL;\n\t\t\tmat = new THREE[c.matConfig.type](c.matConfig);\n\t\t\tthis._matCache[c.matConfig.mat_cache_id] = mat;\n\t\t}*/\n\n\t\tvar tile = new vg.Tile({\n\t\t\tsize: this.cellSize,\n\t\t\tscale: scale,\n\t\t\tcell: cell,\n\t\t\tgeometry: geo,\n\t\t\tmaterial: material\n\t\t});\n\n\t\tcell.tile = tile;\n\n\t\treturn tile;\n\t},\n\n\tgenerateTiles: function(config) {\n\t\tconfig = config || {};\n\t\tvar tiles = [];\n\t\tvar settings = {\n\t\t\ttileScale: 0.95,\n\t\t\tcellSize: this.cellSize,\n\t\t\tmaterial: null,\n\t\t\textrudeSettings: {\n\t\t\t\tamount: 1,\n\t\t\t\tbevelEnabled: true,\n\t\t\t\tbevelSegments: 1,\n\t\t\t\tsteps: 1,\n\t\t\t\tbevelSize: 0.5,\n\t\t\t\tbevelThickness: 0.5\n\t\t\t}\n\t\t};\n\t\tsettings = vg.Tools.merge(settings, config);\n\n\t\t/*if (!settings.material) {\n\t\t\tsettings.material = new THREE.MeshPhongMaterial({\n\t\t\t\tcolor: vg.Tools.randomizeRGB('30, 30, 30', 10)\n\t\t\t});\n\t\t}*/\n\n\t\t// overwrite with any new dimensions\n\t\tthis.cellSize = settings.cellSize;\n\t\tthis._cellWidth = this.cellSize * 2;\n\t\tthis._cellLength = (vg.SQRT3 * 0.5) * this._cellWidth;\n\n\t\tthis.autogenerated = true;\n\t\tthis.extrudeSettings = settings.extrudeSettings;\n\n\t\tvar i, t, c;\n\t\tfor (i in this.cells) {\n\t\t\tc = this.cells[i];\n\t\t\tt = this.generateTile(c, settings.tileScale, settings.material);\n\t\t\tt.position.copy(this.cellToPixel(c));\n\t\t\tt.position.y = 0;\n\t\t\ttiles.push(t);\n\t\t}\n\t\treturn tiles;\n\t},\n\n\tgenerateTilePoly: function(material) {\n\t\tif (!material) {\n\t\t\tmaterial = new THREE.MeshBasicMaterial({color: 0x24b4ff});\n\t\t}\n\t\tvar mesh = new THREE.Mesh(this.cellShapeGeo, material);\n\t\tthis._vec3.set(1, 0, 0);\n\t\tmesh.rotateOnAxis(this._vec3, vg.PI/2);\n\t\treturn mesh;\n\t},\n\n\t// create a flat, hexagon-shaped grid\n\tgenerate: function(config) {\n\t\tconfig = config || {};\n\t\tthis.size = typeof config.size === 'undefined' ? this.size : config.size;\n\t\tvar x, y, z, c;\n\t\tfor (x = -this.size; x < this.size+1; x++) {\n\t\t\tfor (y = -this.size; y < this.size+1; y++) {\n\t\t\t\tz = -x-y;\n\t\t\t\tif (Math.abs(x) <= this.size && Math.abs(y) <= this.size && Math.abs(z) <= this.size) {\n\t\t\t\t\tc = new vg.Cell(x, y, z);\n\t\t\t\t\tthis.add(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tgenerateOverlay: function(size, overlayObj, overlayMat) {\n\t\tvar x, y, z;\n\t\tvar geo = this.cellShape.createPointsGeometry();\n\t\tfor (x = -size; x < size+1; x++) {\n\t\t\tfor (y = -size; y < size+1; y++) {\n\t\t\t\tz = -x-y;\n\t\t\t\tif (Math.abs(x) <= size && Math.abs(y) <= size && Math.abs(z) <= size) {\n\t\t\t\t\tthis._cel.set(x, y, z); // define the cell\n\t\t\t\t\tvar line = new THREE.Line(geo, overlayMat);\n\t\t\t\t\tline.position.copy(this.cellToPixel(this._cel));\n\t\t\t\t\tline.rotation.x = 90 * vg.DEG_TO_RAD;\n\t\t\t\t\toverlayObj.add(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tadd: function(cell) {\n\t\tvar h = this.cellToHash(cell);\n\t\tif (this.cells[h]) {\n\t\t\t// console.warn('A cell already exists there');\n\t\t\treturn;\n\t\t}\n\t\tthis.cells[h] = cell;\n\t\tthis.numCells++;\n\n\t\treturn cell;\n\t},\n\n\tremove: function(cell) {\n\t\tvar h = this.cellToHash(cell);\n\t\tif (this.cells[h]) {\n\t\t\tdelete this.cells[h];\n\t\t\tthis.numCells--;\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\tthis.cells = null;\n\t\tthis.numCells = 0;\n\t\tthis.cellShape = null;\n\t\tthis.cellGeo.dispose();\n\t\tthis.cellGeo = null;\n\t\tthis.cellShapeGeo.dispose();\n\t\tthis.cellShapeGeo = null;\n\t\tthis._list = null;\n\t\tthis._vec3 = null;\n\t\tthis._conversionVec = null;\n\t\tthis._geoCache = null;\n\t\tthis._matCache = null;\n\t},\n\n\t/*\n\t\tLoad a grid from a parsed json object.\n\t\tjson = {\n\t\t\textrudeSettings,\n\t\t\tsize,\n\t\t\tcellSize,\n\t\t\tautogenerated,\n\t\t\tcells: [],\n\t\t\tmaterials: [\n\t\t\t\t{\n\t\t\t\t\tcache_id: 0,\n\t\t\t\t\ttype: 'MeshLambertMaterial',\n\t\t\t\t\tcolor, ambient, emissive, reflectivity, refractionRatio, wrapAround,\n\t\t\t\t\timgURL: url\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcacheId: 1, ...\n\t\t\t\t}\n\t\t\t\t...\n\t\t\t]\n\t\t}\n\t*/\n\tload: function(url, cb, scope) {\n\t\tvar self = this;\n\t\tvg.Tools.getJSON({\n\t\t\turl: url,\n\t\t\tcallback: function(json) {\n\t\t\t\tself.fromJSON(json);\n\t\t\t\tcb.call(scope || null, json);\n\t\t\t},\n\t\t\tcache: false,\n\t\t\tscope: self\n\t\t});\n\t},\n\n\tfromJSON: function(json) {\n\t\tvar i, c;\n\t\tvar cells = json.cells;\n\n\t\tthis.cells = {};\n\t\tthis.numCells = 0;\n\n\t\tthis.size = json.size;\n\t\tthis.cellSize = json.cellSize;\n\t\tthis._cellWidth = this.cellSize * 2;\n\t\tthis._cellLength = (vg.SQRT3 * 0.5) * this._cellWidth;\n\n\t\tthis.extrudeSettings = json.extrudeSettings;\n\t\tthis.autogenerated = json.autogenerated;\n\n\t\tfor (i = 0; i < cells.length; i++) {\n\t\t\tc = new vg.Cell();\n\t\t\tc.copy(cells[i]);\n\t\t\tthis.add(c);\n\t\t}\n\t},\n\n\ttoJSON: function() {\n\t\tvar json = {\n\t\t\tsize: this.size,\n\t\t\tcellSize: this.cellSize,\n\t\t\textrudeSettings: this.extrudeSettings,\n\t\t\tautogenerated: this.autogenerated\n\t\t};\n\t\tvar cells = [];\n\t\tvar c, k;\n\n\t\tfor (k in this.cells) {\n\t\t\tc = this.cells[k];\n\t\t\tcells.push({\n\t\t\t\tq: c.q,\n\t\t\t\tr: c.r,\n\t\t\t\ts: c.s,\n\t\t\t\th: c.h,\n\t\t\t\twalkable: c.walkable,\n\t\t\t\tuserData: c.userData\n\t\t\t});\n\t\t}\n\t\tjson.cells = cells;\n\n\t\treturn json;\n\t},\n\n\t/*  ________________________________________________________________________\n\t\tHexagon-specific conversion math\n\t\tMostly commented out because they're inlined whenever possible to increase performance.\n\t\tThey're still here for reference.\n\t */\n\n\t_createVertex: function(i) {\n\t\tvar angle = (vg.TAU / 6) * i;\n\t\treturn new THREE.Vector3((this.cellSize * Math.cos(angle)), (this.cellSize * Math.sin(angle)), 0);\n\t},\n\n\t/*_pixelToAxial: function(pos) {\n\t\tvar q, r; // = x, y\n\t\tq = pos.x * ((2/3) / this.cellSize);\n\t\tr = ((-pos.x / 3) + (vg.SQRT3/3) * pos.y) / this.cellSize;\n\t\tthis._cel.set(q, r, -q-r);\n\t\treturn this._cubeRound(this._cel);\n\t},*/\n\n\t/*_axialToCube: function(h) {\n\t\treturn {\n\t\t\tq: h.q,\n\t\t\tr: h.r,\n\t\t\ts: -h.q - h.r\n\t\t};\n\t},*/\n\n\t/*_cubeToAxial: function(cell) {\n\t\treturn cell; // yep\n\t},*/\n\n\t/*_axialToPixel: function(cell) {\n\t\tvar x, y; // = q, r\n\t\tx = cell.q * this._cellWidth * 0.75;\n\t\ty = (cell.s - cell.r) * this._cellLength * 0.5;\n\t\treturn {x: x, y: -y};\n\t},*/\n\n\t/*_hexToPixel: function(h) {\n\t\tvar x, y; // = q, r\n\t\tx = this.cellSize * 1.5 * h.x;\n\t\ty = this.cellSize * vg.SQRT3 * (h.y + (h.x * 0.5));\n\t\treturn {x: x, y: y};\n\t},*/\n\n\t/*_axialRound: function(h) {\n\t\treturn this._cubeRound(this.axialToCube(h));\n\t},*/\n\n\t_cubeRound: function(h) {\n\t\tvar rx = Math.round(h.q);\n\t\tvar ry = Math.round(h.r);\n\t\tvar rz = Math.round(h.s);\n\n\t\tvar xDiff = Math.abs(rx - h.q);\n\t\tvar yDiff = Math.abs(ry - h.r);\n\t\tvar zDiff = Math.abs(rz - h.s);\n\n\t\tif (xDiff > yDiff && xDiff > zDiff) {\n\t\t\trx = -ry-rz;\n\t\t}\n\t\telse if (yDiff > zDiff) {\n\t\t\try = -rx-rz;\n\t\t}\n\t\telse {\n\t\t\trz = -rx-ry;\n\t\t}\n\n\t\treturn this._cel.set(rx, ry, rz);\n\t},\n\n\t/*_cubeDistance: function(a, b) {\n\t\treturn Math.max(Math.abs(a.q - b.q), Math.abs(a.r - b.r), Math.abs(a.s - b.s));\n\t}*/\n};\n\nvg.HexGrid.prototype.constructor = vg.HexGrid;\n","/*\n\tGraph of squares. Handles grid cell management (placement math for eg pathfinding, range, etc) and grid conversion math.\n\tInterface:\n\ttype\n\tsize - number of cells (in radius); only used if the map is generated\n\tcellSize\n\tcells - a hash so we can have sparse maps\n\tnumCells\n\textrudeSettings\n\tautogenerated\n\tcellShape\n\tcellGeo\n\tcellShapeGeo\n\n\t@author Corey Birnbaum https://github.com/vonWolfehaus/\n */\nvg.SqrGrid = function(config) {\n\tconfig = config || {};\n\t/*  ______________________________________________\n\t\tGRID INTERFACE:\n\t*/\n\tthis.type = vg.SQR;\n\tthis.size = 5; // only used for generated maps\n\tthis.cellSize = typeof config.cellSize === 'undefined' ? 10 : config.cellSize;\n\tthis.cells = {};\n\tthis.numCells = 0;\n\n\tthis.extrudeSettings = null;\n\tthis.autogenerated = false;\n\n\t// create base shape used for building geometry\n\tvar verts = [];\n\tverts.push(new THREE.Vector3());\n\tverts.push(new THREE.Vector3(-this.cellSize, this.cellSize));\n\tverts.push(new THREE.Vector3(this.cellSize, this.cellSize));\n\tverts.push(new THREE.Vector3(this.cellSize, -this.cellSize));\n\t// copy the verts into a shape for the geometry to use\n\tthis.cellShape = new THREE.Shape();\n\tthis.cellShape.moveTo(-this.cellSize, -this.cellSize);\n\tthis.cellShape.lineTo(-this.cellSize, this.cellSize);\n\tthis.cellShape.lineTo(this.cellSize, this.cellSize);\n\tthis.cellShape.lineTo(this.cellSize, -this.cellSize);\n\tthis.cellShape.lineTo(-this.cellSize, -this.cellSize);\n\n\tthis.cellGeo = new THREE.Geometry();\n\tthis.cellGeo.vertices = verts;\n\tthis.cellGeo.verticesNeedUpdate = true;\n\n\tthis.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape);\n\n\t/*  ______________________________________________\n\t\tPRIVATE\n\t*/\n\n\tthis._fullCellSize = this.cellSize * 2;\n\tthis._hashDelimeter = '.';\n\t// pre-computed permutations\n\tthis._directions = [new vg.Cell(+1, 0, 0), new vg.Cell(0, -1, 0),\n\t\t\t\t\t\tnew vg.Cell(-1, 0, 0), new vg.Cell(0, +1, 0)];\n\tthis._diagonals = [new vg.Cell(-1, -1, 0), new vg.Cell(-1, +1, 0),\n\t\t\t\t\t   new vg.Cell(+1, +1, 0), new vg.Cell(+1, -1, 0)];\n\t// cached objects\n\tthis._list = [];\n\tthis._vec3 = new THREE.Vector3();\n\tthis._cel = new vg.Cell();\n\tthis._conversionVec = new THREE.Vector3();\n\tthis._geoCache = [];\n\tthis._matCache = [];\n};\n\nvg.SqrGrid.prototype = {\n\t/*\n\t\t________________________________________________________________________\n\t\tHigh-level functions that the Board interfaces with (all grids implement)\n\t */\n\n\tcellToPixel: function(cell) {\n\t\tthis._vec3.x = cell.q * this._fullCellSize;\n\t\tthis._vec3.y = cell.h;\n\t\tthis._vec3.z = cell.r * this._fullCellSize;\n\t\treturn this._vec3;\n\t},\n\n\tpixelToCell: function(pos) {\n\t\tvar q = Math.round(pos.x / this._fullCellSize);\n\t\tvar r = Math.round(pos.z / this._fullCellSize);\n\t\treturn this._cel.set(q, r, 0);\n\t},\n\n\tgetCellAt: function(pos) {\n\t\tvar q = Math.round(pos.x / this._fullCellSize);\n\t\tvar r = Math.round(pos.z / this._fullCellSize);\n\t\tthis._cel.set(q, r);\n\t\treturn this.cells[this.cellToHash(this._cel)];\n\t},\n\n\tgetNeighbors: function(cell, diagonal, filter) {\n\t\t// always returns an array\n\t\tvar i, n, l = this._directions.length;\n\t\tthis._list.length = 0;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tthis._cel.copy(cell);\n\t\t\tthis._cel.add(this._directions[i]);\n\t\t\tn = this.cells[this.cellToHash(this._cel)];\n\t\t\tif (!n || (filter && !filter(cell, n))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._list.push(n);\n\t\t}\n\t\tif (diagonal) {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tthis._cel.copy(cell);\n\t\t\t\tthis._cel.add(this._diagonals[i]);\n\t\t\t\tn = this.cells[this.cellToHash(this._cel)];\n\t\t\t\tif (!n || (filter && !filter(cell, n))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._list.push(n);\n\t\t\t}\n\t\t}\n\t\treturn this._list;\n\t},\n\n\tgetRandomCell: function() {\n\t\tvar c, i = 0, x = vg.Tools.randomInt(0, this.numCells);\n\t\tfor (c in this.cells) {\n\t\t\tif (i === x) {\n\t\t\t\treturn this.cells[c];\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn this.cells[c];\n\t},\n\n\tcellToHash: function(cell) {\n\t\treturn cell.q+this._hashDelimeter+cell.r; // s is not used in a square grid\n\t},\n\n\tdistance: function(cellA, cellB) {\n\t\tvar d = Math.max(Math.abs(cellA.q - cellB.q), Math.abs(cellA.r - cellB.r));\n\t\td += cellB.h - cellA.h; // include vertical size\n\t\treturn d;\n\t},\n\n\tclearPath: function() {\n\t\tvar i, c;\n\t\tfor (i in this.cells) {\n\t\t\tc = this.cells[i];\n\t\t\tc._calcCost = 0;\n\t\t\tc._priority = 0;\n\t\t\tc._parent = null;\n\t\t\tc._visited = false;\n\t\t}\n\t},\n\n\ttraverse: function(cb) {\n\t\tvar i;\n\t\tfor (i in this.cells) {\n\t\t\tcb(this.cells[i]);\n\t\t}\n\t},\n\n\tgenerateTile: function(cell, scale, material) {\n\t\tvar height = Math.abs(cell.h);\n\t\tif (height < 1) height = 1;\n\n\t\tvar geo = this._geoCache[height];\n\t\tif (!geo) {\n\t\t\tthis.extrudeSettings.amount = height;\n\t\t\tgeo = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings);\n\t\t\tthis._geoCache[height] = geo;\n\t\t}\n\n\t\t/*mat = this._matCache[c.matConfig.mat_cache_id];\n\t\tif (!mat) { // MaterialLoader? we currently only support basic stuff though. maybe later\n\t\t\tmat.map = Loader.loadTexture(c.matConfig.imgURL);\n\t\t\tdelete c.matConfig.imgURL;\n\t\t\tmat = new THREE[c.matConfig.type](c.matConfig);\n\t\t\tthis._matCache[c.matConfig.mat_cache_id] = mat;\n\t\t}*/\n\n\t\tvar t = new vg.Tile({\n\t\t\tsize: this.cellSize,\n\t\t\tscale: scale,\n\t\t\tcell: cell,\n\t\t\tgeometry: geo,\n\t\t\tmaterial: material\n\t\t});\n\n\t\tcell.tile = t;\n\n\t\treturn t;\n\t},\n\n\tgenerateTiles: function(config) {\n\t\tconfig = config || {};\n\t\tvar tiles = [];\n\t\tvar settings = {\n\t\t\ttileScale: 0.95,\n\t\t\tcellSize: this.cellSize,\n\t\t\tmaterial: null,\n\t\t\textrudeSettings: {\n\t\t\t\tamount: 1,\n\t\t\t\tbevelEnabled: true,\n\t\t\t\tbevelSegments: 1,\n\t\t\t\tsteps: 1,\n\t\t\t\tbevelSize: 0.5,\n\t\t\t\tbevelThickness: 0.5\n\t\t\t}\n\t\t};\n\t\tsettings = vg.Tools.merge(settings, config);\n\n\t\t/*if (!settings.material) {\n\t\t\tsettings.material = new THREE.MeshPhongMaterial({\n\t\t\t\tcolor: vg.Tools.randomizeRGB('30, 30, 30', 10)\n\t\t\t});\n\t\t}*/\n\n\t\t// overwrite with any new dimensions\n\t\tthis.cellSize = settings.cellSize;\n\t\tthis._fullCellSize = this.cellSize * 2;\n\n\t\tthis.autogenerated = true;\n\t\tthis.extrudeSettings = settings.extrudeSettings;\n\n\t\tvar i, t, c;\n\t\tfor (i in this.cells) {\n\t\t\tc = this.cells[i];\n\t\t\tt = this.generateTile(c, settings.tileScale, settings.material);\n\t\t\tt.position.copy(this.cellToPixel(c));\n\t\t\tt.position.y = 0;\n\t\t\ttiles.push(t);\n\t\t}\n\t\treturn tiles;\n\t},\n\n\tgenerateTilePoly: function(material) {\n\t\tif (!material) {\n\t\t\tmaterial = new THREE.MeshBasicMaterial({color: 0x24b4ff});\n\t\t}\n\t\tvar mesh = new THREE.Mesh(this.cellShapeGeo, material);\n\t\tthis._vec3.set(1, 0, 0);\n\t\tmesh.rotateOnAxis(this._vec3, vg.PI/2);\n\t\treturn mesh;\n\t},\n\n\t// create a flat, square-shaped grid\n\tgenerate: function(config) {\n\t\tconfig = config || {};\n\t\tthis.size = typeof config.size === 'undefined' ? this.size : config.size;\n\t\tvar x, y, c;\n\t\tvar half = Math.ceil(this.size / 2);\n\t\tfor (x = -half; x < half; x++) {\n\t\t\tfor (y = -half; y < half; y++) {\n\t\t\t\tc = new vg.Cell(x, y + 1);\n\t\t\t\tthis.add(c);\n\t\t\t}\n\t\t}\n\t},\n\n\tgenerateOverlay: function(size, overlayObj, overlayMat) {\n\t\tvar x, y;\n\t\tvar half = Math.ceil(size / 2);\n\t\tfor (x = -half; x < half; x++) {\n\t\t\tfor (y = -half; y < half; y++) {\n\t\t\t\tthis._cel.set(x, y); // define the cell\n\t\t\t\tvar line = new THREE.Line(this.cellGeo, overlayMat);\n\t\t\t\tline.position.copy(this.cellToPixel(this._cel));\n\t\t\t\tline.rotation.x = 90 * vg.DEG_TO_RAD;\n\t\t\t\toverlayObj.add(line);\n\t\t\t}\n\t\t}\n\t},\n\n\tadd: function(cell) {\n\t\tvar h = this.cellToHash(cell);\n\t\tif (this.cells[h]) {\n\t\t\t// console.warn('A cell already exists there');\n\t\t\treturn;\n\t\t}\n\t\tthis.cells[h] = cell;\n\t\tthis.numCells++;\n\n\t\treturn cell;\n\t},\n\n\tremove: function(cell) {\n\t\tvar h = this.cellToHash(cell);\n\t\tif (this.cells[h]) {\n\t\t\tdelete this.cells[h];\n\t\t\tthis.numCells--;\n\t\t}\n\t},\n\n\tdispose: function() {\n\t\tthis.cells = null;\n\t\tthis.numCells = 0;\n\t\tthis.cellShape = null;\n\t\tthis.cellGeo.dispose();\n\t\tthis.cellGeo = null;\n\t\tthis.cellShapeGeo.dispose();\n\t\tthis.cellShapeGeo = null;\n\t\tthis._list = null;\n\t\tthis._vec3 = null;\n\t\tthis._conversionVec = null;\n\t\tthis._geoCache = null;\n\t\tthis._matCache = null;\n\t},\n\n\t/*\n\t\tLoad a grid from a parsed json object.\n\t\tjson = {\n\t\t\textrudeSettings,\n\t\t\tsize,\n\t\t\tcellSize,\n\t\t\tautogenerated,\n\t\t\tcells: [],\n\t\t\tmaterials: [\n\t\t\t\t{\n\t\t\t\t\tcache_id: 0,\n\t\t\t\t\ttype: 'MeshLambertMaterial',\n\t\t\t\t\tcolor, ambient, emissive, reflectivity, refractionRatio, wrapAround,\n\t\t\t\t\timgURL: url\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcacheId: 1, ...\n\t\t\t\t}\n\t\t\t\t...\n\t\t\t]\n\t\t}\n\t*/\n\tload: function(url, callback, scope) {\n\t\tvg.Tools.getJSON({\n\t\t\turl: url,\n\t\t\tcallback: function(json) {\n\t\t\t\tthis.fromJSON(json);\n\t\t\t\tcallback.call(scope || null, json);\n\t\t\t},\n\t\t\tcache: false,\n\t\t\tscope: this\n\t\t});\n\t},\n\n\tfromJSON: function(json) {\n\t\tvar i, c;\n\t\tvar cells = json.cells;\n\n\t\tthis.cells = {};\n\t\tthis.numCells = 0;\n\n\t\tthis.size = json.size;\n\t\tthis.cellSize = json.cellSize;\n\t\tthis._fullCellSize = this.cellSize * 2;\n\t\tthis.extrudeSettings = json.extrudeSettings;\n\t\tthis.autogenerated = json.autogenerated;\n\n\t\tfor (i = 0; i < cells.length; i++) {\n\t\t\tc = new vg.Cell();\n\t\t\tc.copy(cells[i]);\n\t\t\tthis.add(c);\n\t\t}\n\t},\n\n\ttoJSON: function() {\n\t\tvar json = {\n\t\t\tsize: this.size,\n\t\t\tcellSize: this.cellSize,\n\t\t\textrudeSettings: this.extrudeSettings,\n\t\t\tautogenerated: this.autogenerated\n\t\t};\n\t\tvar cells = [];\n\t\tvar c, k;\n\n\t\tfor (k in this.cells) {\n\t\t\tc = this.cells[k];\n\t\t\tcells.push({\n\t\t\t\tq: c.q,\n\t\t\t\tr: c.r,\n\t\t\t\ts: c.s,\n\t\t\t\th: c.h,\n\t\t\t\twalkable: c.walkable,\n\t\t\t\tuserData: c.userData\n\t\t\t});\n\t\t}\n\t\tjson.cells = cells;\n\n\t\treturn json;\n\t}\n};\n\nvg.SqrGrid.prototype.constructor = vg.SqrGrid;\n","/*\n\tExample tile class that constructs its geometry for rendering and holds some gameplay properties.\n\n\t@author Corey Birnbaum https://github.com/vonWolfehaus/\n*/\nvg.Tile = function(config) {\n\tconfig = config || {};\n\tvar settings = {\n\t\tcell: null, // required vg.Cell\n\t\tgeometry: null, // required threejs geometry\n\t\tmaterial: null // not required but it would improve performance significantly\n\t};\n\tsettings = vg.Tools.merge(settings, config);\n\n\tif (!settings.cell || !settings.geometry) {\n\t\tthrow new Error('Missing vg.Tile configuration');\n\t}\n\n\tthis.cell = settings.cell;\n\tif (this.cell.tile && this.cell.tile !== this) this.cell.tile.dispose(); // remove whatever was there\n\tthis.cell.tile = this;\n\n\tthis.uniqueID = vg.Tools.generateID();\n\n\tthis.geometry = settings.geometry;\n\tthis.material = settings.material;\n\tif (!this.material) {\n\t\tthis.material = new THREE.MeshPhongMaterial({\n\t\t\tcolor: vg.Tools.randomizeRGB('30, 30, 30', 13)\n\t\t});\n\t}\n\n\tthis.objectType = vg.TILE;\n\tthis.entity = null;\n\tthis.userData = {};\n\n\tthis.selected = false;\n\tthis.highlight = '0x0084cc';\n\n\tthis.mesh = new THREE.Mesh(this.geometry, this.material);\n\tthis.mesh.userData.structure = this;\n\n\t// create references so we can control orientation through this (Tile), instead of drilling down\n\tthis.position = this.mesh.position;\n\tthis.rotation = this.mesh.rotation;\n\n\t// rotate it to face \"up\" (the threejs coordinate space is Y+)\n\tthis.rotation.x = -90 * vg.DEG_TO_RAD;\n\tthis.mesh.scale.set(settings.scale, settings.scale, 1);\n\n\tif (this.material.emissive) {\n\t\tthis._emissive = this.material.emissive.getHex();\n\t}\n\telse {\n\t\tthis._emissive = null;\n\t}\n\n\tthis.customizeTile();\n};\n\nvg.Tile.prototype = {\n\tselect: function() {\n\t\tif (this.material.emissive) {\n\t\t\tthis.material.emissive.setHex(this.highlight);\n\t\t}\n\t\tthis.selected = true;\n\t\treturn this;\n\t},\n\n\tdeselect: function() {\n\t\tif (this._emissive !== null && this.material.emissive) {\n\t\t\tthis.material.emissive.setHex(this._emissive);\n\t\t}\n\t\tthis.selected = false;\n\t\treturn this;\n\t},\n\n\ttoggle: function() {\n\t\tif (this.selected) {\n\t\t\tthis.deselect();\n\t\t}\n\t\telse {\n\t\t\tthis.select();\n\t\t}\n\t\treturn this;\n\t},\n\n  customizeTile: function() {\n    this.updateTerrain();\n    this.updateCity();\n  },\n\n\n  // setters\n  setTerrain: function(terrain) {\n\t  this.cell.userData.terrain = terrain;\n\t  this.customizeTile();\n  },\n\n  setCity: function(name) {\n    this.cell.userData.city = this.cell.userData.city || {};\n    this.cell.userData.city.name = name;\n    this.customizeTile();\n  },\n\n  setCityPosition: function(position) {\n    this.cell.userData.city = this.cell.userData.city || {};\n    this.cell.userData.city.position = position;\n    this.customizeTile();\n  },\n\n  // customizers\n  updateTerrain: function() {\n\t  var terrain = this.cell.userData.terrain;\n    var colorString = 'rgb(30, 30, 30)';\n\n    if (terrain === 'forest') {\n      colorString = 'rgb(89, 160, 72)';\n    } else if (terrain === 'farm') {\n      colorString = 'rgb(237, 208, 23)';\n    } else if (terrain === 'hills') {\n      colorString = 'rgb(183, 160, 115)';\n    }\n\n    this.material.color = new THREE.Color( colorString );\n  },\n\n  updateCity: function() {\n    var city = this.cell.userData.city;\n    if (city && city.name && city.name.length > 0) {\n      var spriteConfig = {\n        container: board.group,\n        url: '../examples/img/water.png',\n        scale: 3,\n        heightOffset: 2\n      };\n\n      this.sprite = this.sprite || new Sprite(spriteConfig);\n      this.sprite.activate(0, 3, 0);\n\n      var xOffset = 0;\n      var zOffset = 0;\n\n      if (city && city.position) {\n        if (city.position === 1) {\n          xOffset = 5;\n          zOffset = -9;\n        } else if (city.position === 2) {\n          xOffset = 10;\n          zOffset = 0;\n        } else if (city.position === 3) {\n          xOffset = 5;\n          zOffset = 9;\n        } else if (city.position === 4) {\n          xOffset = -5;\n          zOffset = 9;\n        } else if (city.position === 5) {\n          xOffset = -10;\n          zOffset = 0;\n        } else if (city.position === 6) {\n          xOffset = -5;\n          zOffset = -9;\n        }\n      }\n\n      console.log('xOffset: ', xOffset);\n      console.log('zOffset: ', zOffset);\n      board.setEntityOnTileWithOffset(this.sprite, this, xOffset, zOffset);\n    }\n  },\n\n\tdispose: function() {\n\t\tif (this.cell && this.cell.tile) this.cell.tile = null;\n\t\tthis.cell = null;\n\t\tthis.position = null;\n\t\tthis.rotation = null;\n\t\tif (this.mesh.parent) this.mesh.parent.remove(this.mesh);\n\t\tthis.mesh.userData.structure = null;\n\t\tthis.mesh = null;\n\t\tthis.material = null;\n\t\tthis.userData = null;\n\t\tthis.entity = null;\n\t\tthis.geometry = null;\n\t\tthis._emissive = null;\n\t}\n};\n\nvg.Tile.prototype.constructor = vg.Tile;\n"]}